# Strategy

- O padrão Strategy procura encapsular uma família de algoritmos, através de uma interface com um método abstrato que é capaz de invocar determinada rotina ou algoritmo de modo completo, sem nenhuma parte interna do método que varie. Um exemplo clássico disso seria a implementação de um conjunto de algoritmos de ordenação, onde temos por exemplo o Bubble Sort, Insertion Sort, Quick Sort, Merge Sort, entre outros. Utilizando o padrão Strategy, seria possível criar uma interface chamada Sort com o método abstrato chamado "doAlgorithm()" que seria implementado pelas classes concretas para executar o algoritmo de ordenação desejado. Essa interface precisará fazer parte de um cliente (ou sujeito) por agregação. Esse cliente irá, durante determinada rotina, invocar o método de ordenação do seu objeto Sort que, a depender de qual classe concreta seja instanciada para esse objeto, efetuará um algoritmo de ordenação diferente.

# Template Method

- O padrão Template Method procura criar uma classe abstrata com um método que representa determinada rotina onde existem partes que são fixas e outras que são variáveis. Essas partes variáveis devem ser invocadas através de métodos abstratos a serem implementados pelas classes concretas da interface. Já as partes fixas dessa rotina não teriam alteração, independente do que acontecesse durante o processo. Um belo exemplo de implementação desse padrão é em uma classe que representa um processo de compactação de um conjunto de documentos de um diretório. O processo de abertura do diretório e carregamento dos documentos poderia ser fixo na classe, enquanto que o processo de compactação poderia ser variável, fazendo com que seja possível ter um conjunto de classes concretas que implementem esse algoritmo.

# Semelhanças e diferenças

- A principal semelhança entre esses dois padrões é o fato de que ambos tratam procedimentos ou rotinas de código que costumam variar. Enquanto que o Strategy procura variar toda a rotina sem nenhuma parte fixa na interface, o Template Method permite que apenas algumas partes dessa rotina sejam variáveis, enquanto que outras sejam fixas. É possível notar que o padrão Factory Method funciona através de um Template Method, mas o seu foco é no processo de criação de instâncias de classes concretas de determinada interface. Um belo exemplo de implementação é um sistema de autenticação onde é possível realizar as partes fixas de: identificar o usuário do sistema e tratar os dados do mesmo; enquanto que as partes variáveis seriam: rodar um processo de autenticação e autorização que avaliasse as permissões do usuário (isso funcionaria como um backend de autenticação e autorização, por exemplo).

# Outros exemplos

- Strategy: Além do algoritmo de ordenação dado como exemplo, é possível citar também outros tipos de algoritmos como de busca (Busca Linear, Busca Binária) ou para percorrer um grafo acíclico dirigido (Depth First Search (que também pode ser em-ordem, pós-ordem ou pré-ordem), Breadth First Search). Além disso, um exemplo prático pode ser visto em aplicativos de manipulação de imagem, onde é possível salvar a imagem em diferentes formatos (ex: PNG, JPEG, GIF, SVG). Esse processo de salvamento da imagem poderia ser encarado como um Strategy, onde o algoritmo receberia a Imagem e cuidaria de todo o processo de compactação, gerar assinaturas, metadados e etc.

- Template Method: Além do sistema de autenticação, é possível utilizar o Template Method de forma prática em um desses aplicativos simples de chat para comunicação com diversas plataformas, como por exemplo o Whatsapp, Telegram ou algum com o IRC. As partes fixas do método seriam o tratamento da mensagem e identificação do remetente e destinatário, enquanto que o processo de envio e recebimento da mesma seriam variáveis, dependendo de cada plataforma e sendo implementada nas classes concretas da classe abstrata com o Template Method.
